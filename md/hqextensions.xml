<?xml version="1.0" encoding="utf-8"?>
<mdscript name="Valrinn_HQExtensions" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="md.xsd">
  <cues>
    <cue name="Setup">
      <conditions>
        <event_cue_signalled cue="md.Setup.Start" />
      </conditions>
      <actions>
        <debug_text text="'VALRINN DEBUG: Setup cue triggered'" filter="error" />
        <!-- Start Ware Teleportation immediately -->
        <signal_cue cue="WareTeleportation" />
      </actions>
      <cues>
        <!-- Ensure WareTeleportation starts on load for existing saves -->
        <cue name="ForceStart" instantiate="true">
          <conditions>
            <event_game_loaded />
          </conditions>
          <actions>
            <set_value name="$wareResearch" exact="event.param2" />
            <set_value name="$wareBlueprintList" exact="$mapResearch.{$wareResearch}" />
            <!-- Add module blueprints. -->
            <add_blueprints wares="$wareBlueprintList"/>
            <!-- Prepare and show notification to the player. -->
            <substitute_text text="$head" source="{1015,1101}">
              <replace string="'$WARE$'" with="$wareResearch.name"/>
            </substitute_text>
            <show_notification text="[$head, '', {1015,71001}]" priority="2" sound="notification_achievement" />
            <!-- Start ware teleportation if needed. -->
            <do_if value="$wareResearch == ware.research_teleportation">
              <signal_cue cue="WareTeleportation" />
            </do_if>
            <!-- Cleanup. -->
            <remove_value name="$wareResearch" />
            <remove_value name="$wareBlueprintList" />
            <remove_value name="$head" />
          </actions>
        </cue>
        <!-- Check unlocked research before work starts (e.g. custom game start with unlocked research). -->
        <cue name="ResearchPreSet">
          <delay exact="5s" /> 
          <actions>
            <debug_text text="'VALRINN DEBUG: ResearchPreSet executing. Checking ' + $mapResearch.keys.count + ' research items.'" />
            <do_for_each name="$wareResearch" valuename="$wareBlueprintList" in="$mapResearch">
              <debug_text text="'VALRINN DEBUG: Checking ' + $wareResearch.name + ' Unlocked: ' + $wareResearch.research.unlocked" />
              <do_if value="$wareResearch.research.unlocked">
                <do_if value="$wareResearch == ware.research_teleportation and WareTeleportation.state == cuestate.waiting">
                  <debug_text text="'VALRINN DEBUG: ResearchPreSet found unlocked teleport research. Starting WareTeleportation.'" />
                  <signal_cue cue="WareTeleportation" />
                </do_if>
                <do_else>
                  <!-- Add module blueprints. -->
                  <debug_text text="'VALRINN DEBUG: Unlocking blueprints for ' + $wareResearch.name" />
                  <add_blueprints wares="$wareBlueprintList"/>
                </do_else>
              </do_if>
            </do_for_each>
          </actions>
        </cue>
        <!-- Ensure teleport is used. REMIND: Simply specifying dependency on basic teleport didn't work well for the research graph. -->

        <!-- Dump all research IDs to find the correct vanilla ones for Teleport Range -->
        <cue name="DebugDumpResearch">
           <delay exact="1s"/>
           <actions>
              <set_value name="$allWares" exact="lookup.wares.list" />
              <do_for_each name="$w" in="$allWares">
                 <do_if value="$w.tags.indexof.{tag.research}">
                    <debug_text text="'VALRINN DEBUG: Found Research Ware: ' + $w + ' ID: ' + $w.id" />
                 </do_if>
              </do_for_each>
           </actions>
        </cue>
      </cues>
    </cue>
    <!-- Ware Teleportation Management. -->
    <cue name="WareTeleportation">
      <conditions>
        <event_cue_signalled />
      </conditions>
      <actions>
        <debug_text text="'VALRINN DEBUG: WareTeleportation cue triggered'" filter="error" />
        <set_value name="$headquarters" exact="player.headquarters"/>
        <do_if value="not $headquarters">
             <!-- Fallback to the original method if player.headquarters is not set (though unlikely if plot is done) -->
             <set_value name="$headquarters" exact="md.X4Ep1_Mentor_Subscriptions.Start.$HQ"/>
        </do_if>
        <assert value="$headquarters != null" text="'Headquarters is absent'"/>

        <set_value name="$teleportEnergyWare" exact="ware.energycells" />
        <set_value name="$teleportEnergyCost" exact="1.0 / 50.0" />

        <set_value name="$macroCoordinator" exact="macro.module_valr_logistics_coordinator_macro" />
        <set_value name="$macroDispatcher" exact="macro.module_valr_logistics_dispatcher_macro" />
        <set_value name="$macroCatcher" exact="macro.module_valr_logistics_catcher_macro" />

        <set_value name="$moduleCoordinator" exact="null" />
      </actions>
      <cues>
        <cue name="StartupCheck">
          <delay exact="1s"/>
          <actions>
            <!-- Check if module already exists (e.g. Creative Start) -->
            <find_object_component name="$moduleCoordinator" object="$headquarters" macro="$macroCoordinator" />
            <do_if value="$moduleCoordinator">
               <debug_text text="'VALRINN DEBUG: Coordinator found on startup. Signalling constructed.'" />
               <signal_cue cue="CoordinatorConstructed" />
            </do_if>
            <do_else>
               <debug_text text="'VALRINN DEBUG: Coordinator NOT found on startup at ' + $headquarters.name" />
            </do_else>
          </actions>
        </cue>

        <!-- Monitor construction and destruction of the teleport coordinator at HQ. -->
        <cue name="CoordinatorConstructed">
          <conditions>
            <check_any>
                <event_build_finished_components object="$headquarters.buildstorage" />
                <event_cue_signalled cue="this" />
            </check_any>
            <count_object_components object="$headquarters" macro="$macroCoordinator" min="1" />
          </conditions>
          <actions>
            <debug_text text="'VALRINN DEBUG: CoordinatorConstructed cue triggered'" filter="error" />
            <find_object_component name="$moduleCoordinator" object="$headquarters" macro="$macroCoordinator" />
            <signal_cue cue="TeleportOperationsTrigger" />
          </actions>
          <cues>
            <cue name="CoordinatorDestroyed">
              <conditions>
                <event_object_changed_state object="$moduleCoordinator" />
                <check_value value="not event.object.isoperational" />
              </conditions>
              <actions>
                <!-- TODO? Player could build multiple coordinators, account for others. -->
                <reset_cue cue="CoordinatorConstructed" />
                <reset_cue cue="TeleportOperationsTrigger" />
              </actions>
            </cue>
          </cues>
        </cue>
        <cue name="TeleportOperationsTrigger">
          <conditions>
            <event_cue_signalled />
          </conditions>
          <cues>
            <cue name="TeleportOperationsEmitter">
              <actions>
                <debug_text text="'VALRINN DEBUG: TeleportOperationsEmitter signalling TeleportOperations'" />
                <signal_cue cue="TeleportOperations" />
              </actions>
              <cues>
                <cue name="RecheckTeleportOperations">
                  <delay min="5min" max="10min" />
                  <actions>
                    <reset_cue cue="parent" />
                  </actions>
                </cue>
              </cues>
            </cue>
          </cues>
        </cue>
        <!-- Execute ware teleportation operations. -->
        <!-- For each ware separately. Station definition can differ for different wares (e.g., for ore it's consumption, energy cells - trade, microchips - supply).
          Happens in 3 stages:
          1. Teleport from supply stations to consumer stations;
          2. Teleport from trade stations to consumer stations;
          3. Teleport from supply stations (remaining stock) to all trade stations, balancing stock.
          Mutual balancing between trade stations is not performed (pointless micro-management).
          Energy cells are teleported separately after all other wares. Each teleported batch is reduced by the amount needed for the teleport itself.
          Ambiguous stations:
          1. Ware is a pure resource, but there is a sell offer. Ignore sell => likely intended for local sale.
          2. Ware is a product (possibly intermediate), but there is a buy offer. MD cannot distinguish two cases:
            a) buy limit <= sell limit (buying critical shortage) => treat as consumer or supplier;
            b) buy limit > sell limit (trading ware with margins) => treat as trade station.
            Case (a) is considered more common: if selling - supply (ignore buy); if intermediate product - consumption; else nothing.
          3. Ware is a minable resource and there is a sell offer. Treat as product and ignore buy => likely for miners, not external delivery.
            Note: without sell offer, it's a normal buy case (miners or external).
        -->
        <cue name="TeleportOperations" instantiate="true" namespace="this">
          <conditions>
            <event_cue_signalled />
          </conditions>
          <actions>
            <!-- Calculate Max Jumps based on Research -->
            <!-- DISABLED FOR DEBUGGING: Waiting to confirm correct Vanilla IDs from log dump -->
            <set_value name="$maxJumps" exact="999" />
            <debug_text text="'VALRINN DEBUG: Range checks disabled temporarily. Max Jumps set to 999.'" /> 
            
            <!-- Find sending/receiving stations. (Filtered by range later or get all and filter in loop? Get all for now) -->
            <find_station_by_true_owner name="$stationList" faction="faction.player" space="player.galaxy" multiple="true">
              <match_any>
                <match_content macro="WareTeleportation.$macroDispatcher" state="componentstate.operational" />
                <match_content macro="WareTeleportation.$macroCatcher" state="componentstate.operational" />
              </match_any>
            </find_station_by_true_owner>
            <!-- Create ware processing plan. -->
            <set_value name="$warePlan" exact="table[]" />
            <!-- Start station traversal. -->
            <set_value name="$state" exact="'beginStation'" />
            <debug_text text="'VALRINN DEBUG: TeleportOperations started. Max Jumps: ' + $maxJumps + '. Found ' + $stationList.count + ' relevant stations.'" />
          </actions>
          <cues>
            <!-- Process sending station, each ware for each receiving station. -->
            <cue name="ScanStation">
              <delay min="100ms" max="300ms" />
              <actions>
                <do_if value="$state == 'beginStation'">
                  <do_if value="$stationList.count gt 0">
                    <set_value name="$station" exact="$stationList.last" />
                    <remove_value name="$stationList.{$stationList.count}" />
                    <debug_text text="'VALRINN DEBUG: ScanStation processing: ' + $station.name + ' (' + $station.idcode + ')'" />
                    <include_actions ref="FindModulesAndTrades" />
                    <!-- Iterate sell offers. Analyze stations for supply and trade. -->
                    <set_value name="$state" exact="'analyzeSellOffer'" />
                  </do_if>
                  <do_else>
                    <remove_value name="$stationList" />
                    <include_actions ref="PrepareWaresList" />
                    <do_if value="$wares.count == 0">
                      <!-- No wares. -->
                      <remove_value name="$warePlan" />
                      <remove_value name="$wares" />
                      <cancel_cue cue="namespace" />
                    </do_if>
                    <do_else>
                      <!-- Start preparing ware movement plan. -->
                      <set_value name="$wareIndex" exact="1" />
                      <set_value name="$stage" exact="1" />
                      <signal_cue cue="PrepareWareMovesTrigger" />
                    </do_else>
                    <set_value name="$state" exact="'finish'" />
                  </do_else>
                </do_if>

                <do_elseif value="$state == 'analyzeSellOffer'">
                  <do_if value="$sellOfferList.count gt 0">
                    <set_value name="$sellOffer" exact="$sellOfferList.last" />
                    <remove_value name="$sellOfferList.{$sellOfferList.count}" />
                    <include_actions ref="AnalyzeSellOffer" />
                    <remove_value name="$sellOffer" />
                  </do_if>
                  <do_else>
                    <remove_value name="$sellOfferList" />
                    <set_value name="$state" exact="'analyzeBuyOffers'" />
                  </do_else>
                </do_elseif>

                <do_elseif value="$state == 'analyzeBuyOffers'">
                  <include_actions ref="AnalyzeBuyOffers" />
                  <remove_value name="$buyOfferList" />
                  <set_value name="$state" exact="'endStation'" />
                </do_elseif>

                <do_elseif value="$state == 'endStation'">
                  <remove_value name="$station" />
                  <set_value name="$state" exact="'beginStation'" />
                </do_elseif>

                <do_if value="$state == 'finish'">
                  <remove_value name="$state" />
                </do_if>
                <do_else>
                  <reset_cue cue="this" />
                </do_else>
              </actions>
            </cue>
            <!-- Find station modules for dispatch/catch and trade offers. -->
            <library name="FindModulesAndTrades" purpose="include_actions">
              <actions>
                <find_object_component name="$compDispatcher" object="$station" macro="WareTeleportation.$macroDispatcher" checkoperational="true" />
                <find_object_component name="$compCatcher" object="$station" macro="WareTeleportation.$macroCatcher" checkoperational="true" />
                <debug_text text="'VALRINN DEBUG: Station ' + $station.name + ' has Dispatcher: ' + ($compDispatcher != null) + ', Catcher: ' + ($compCatcher != null)" />
                <assert value="$compDispatcher or $compCatcher" />
                <do_if value="$compDispatcher">
                  <!-- Build list of wares for sale. -->
                  <find_sell_offer result="$sellOfferList" seller="$station" excludeempty="false" multiple="true" />
                </do_if>
                <do_else>
                  <create_list name="$sellOfferList" />
                </do_else>
                <do_if value="$compCatcher">
                  <!-- Build list of wares for purchase. -->
                  <find_buy_offer result="$buyOfferList" buyer="$station" excludeempty="false" multiple="true" />
                </do_if>
                <do_else>
                  <create_list name="$buyOfferList" />
                </do_else>
                <remove_value name="$compDispatcher" />
                <remove_value name="$compCatcher" />
              </actions>
            </library>
            <!-- Analyze ware sell offer and add to ware plan. -->
            <library name="AnalyzeSellOffer">
              <actions>
                <set_value name="$ware" exact="$sellOffer.ware" />
                <!-- Sell only if allowed by rule. REMIND: Continue check needed so buy offer isn't processed incorrectly later. -->
                <set_value name="$sellOfferAmount" exact="
                  if ($sellOffer.restriction.inverted and $sellOffer.restriction.factions.indexof.{faction.player}) or (not $sellOffer.restriction.inverted and not $sellOffer.restriction.factions.indexof.{faction.player})
                  then 0 else $sellOffer.amount"
                />
                <include_actions ref="CheckInsertWareIntoPlan" />
                <!-- Find all buy offers for this ware. REMIND: Can be multiple for different storages (normal and ammo/drones). -->
                <set_value name="$buyOfferAmount" exact="0" />
                <do_all exact="$buyOfferList.count" counter="$i" reverse="true">
                  <set_value name="$buyOffer" exact="$buyOfferList.{$i}" />
                  <do_if value="$buyOffer.ware != $ware">
                    <continue />
                  </do_if>
                  <do_if value="($buyOffer.restriction.inverted and $buyOffer.restriction.factions.indexof.{faction.player}) or (not $buyOffer.restriction.inverted and not $buyOffer.restriction.factions.indexof.{faction.player})" negate="true">
                    <set_value name="$buyOfferAmount" operation="add" exact="$buyOffer.desiredamount" />
                  </do_if>
                  <!-- Remove processed offer. -->
                  <remove_value name="$buyOfferList.{$i}" />
                </do_all>
                <do_if value="$station.products.{$ware}.exists">
                  <!-- Possible ambiguous case 2. -->
                  <do_if value="$sellOfferAmount gt 0">
                    <!-- Has product for sale => definitely supply (ignore buy). -->
                    <append_to_list name="$warePlan.{$ware}.$suppliers" exact="table[$station = $station, $sellAmount = $sellOfferAmount]" />
                  </do_if>
                  <do_elseif value="($station.resources.{$ware}.exists or $station.supplyresources.{$ware}.exists) and $buyOfferAmount gt 0">
                    <!-- Ware is currently deficit resource (only buying) => definitely consumption. -->
                    <do_if value="$ware != WareTeleportation.$teleportEnergyWare">
                      <append_to_list name="$warePlan.{$ware}.$consumers" exact="table[$station = $station, $buyAmount = $buyOfferAmount]" />
                    </do_if>
                  </do_elseif>
                  <!-- In other cases too ambiguous => do nothing. -->
                </do_if>
                <do_elseif value="$ware.hastag.minable">
                  <!-- Ambiguous case 3. -->
                  <do_if value="$sellOfferAmount gt 0">
                    <!-- Has product for sale => definitely supply (ignore buy). -->
                    <append_to_list name="$warePlan.{$ware}.$suppliers" exact="table[$station = $station, $sellAmount = $sellOfferAmount]" />
                  </do_if>
                  <!-- Else station waits for next batch from miners. -->
                </do_elseif>
                <do_elseif value="$station.resources.pure.{$ware}.exists or $station.supplyresources.{$ware}.exists">
                  <!-- Ambiguous case 1 => sale ignored => definitely consumption if exists. REMIND: Could be temporary restriction for trade station during drone creation. -->
                  <do_if value="$buyOfferAmount gt 0">
                    <append_to_list name="$warePlan.{$ware}.$consumers" exact="table[$station = $station, $buyAmount = $buyOfferAmount]" />
                  </do_if>
                </do_elseif>
                <do_else>
                  <!-- Definitely trade station. REMIND: Case where sell offer exists without [accessible] buy offer, but not factory/sale, then what? -->
                  <do_if value="$sellOfferAmount gt 0 or $buyOfferAmount gt 0">
                    <append_to_list name="$warePlan.{$ware}.$tradeHubs" exact="table[$station = $station, $sellAmount = $sellOfferAmount, $buyAmount = $buyOfferAmount]" />
                  </do_if>
                </do_else>
                <remove_value name="$ware" />
                <remove_value name="$buyOfferAmount" />
              </actions>
            </library>
            <!-- Analyze remaining buy offers and add to ware plan. -->
            <library name="AnalyzeBuyOffers">
              <actions>
                <!-- Iterate remaining buy offers. Analyze stations for consumption. REMIND: Multiple offers per ware possible. -->
                <do_for_each name="$buyOffer" in="$buyOfferList">
                  <do_if value="($buyOffer.restriction.inverted and $buyOffer.restriction.factions.indexof.{faction.player}) or (not $buyOffer.restriction.inverted and not $buyOffer.restriction.factions.indexof.{faction.player})">
                    <continue />
                  </do_if>
                  <set_value name="$ware" exact="$buyOffer.ware" />
                  <!-- If actually buying. -->
                  <do_if value="$buyOffer.desiredamount gt 0">
                    <include_actions ref="CheckInsertWareIntoPlan" />
                    <do_if value="$station.resources.{$ware}.exists or $station.supplyresources.{$ware}.exists">
                      <!-- Definitely consumer. Even if intermediate product without sell offer. -->
                      <append_to_list name="$warePlan.{$ware}.$consumers" exact="table[$station = $station, $buyAmount = $buyOffer.desiredamount]" />
                    </do_if>
                    <do_elseif value="not $station.products.{$ware}.exists">
                      <!-- Trade station. -->
                      <append_to_list name="$warePlan.{$ware}.$tradeHubs" exact="table[$station = $station, $sellAmount = 0, $buyAmount = $buyOffer.desiredamount]" />
                    </do_elseif>
                  </do_if>
                  <remove_value name="$ware" />
                </do_for_each>
              </actions>
            </library>
            <!-- Prepare list of wares for plan traversal. -->
            <library name="PrepareWaresList">
              <actions>
                <!-- List of wares in plan. -->
                <set_value name="$wares" exact="$warePlan.keys.list" />
                <!-- Move energy cells to end so their absence after teleport doesn't hinder other wares. -->
                <set_value name="$energyWareIndex" exact="$wares.indexof.{WareTeleportation.$teleportEnergyWare}" />
                <do_if value="$energyWareIndex gt 0">
                  <remove_value name="$wares.{$energyWareIndex}" />
                  <append_to_list name="$wares" exact="WareTeleportation.$teleportEnergyWare" />
                </do_if>
                <remove_value name="$energyWareIndex" />
                <debug_text text="'VALRINN DEBUG: PrepareWaresList found wares: ' + $wares" />
              </actions>
            </library>
            <!-- Check and add ware entry to plan. -->
            <library name="CheckInsertWareIntoPlan" purpose="include_actions">
              <actions>
                <do_if value="not $warePlan.{$ware}?">
                  <set_value name="$warePlan.{$ware}" exact="table[$suppliers = [], $consumers = [], $tradeHubs = [], $moves = []]" />
                </do_if>
              </actions>
            </library>

            <!-- Prepare ware movement plan. -->
            <cue name="PrepareWareMovesTrigger">
              <conditions>
                <event_cue_signalled />
              </conditions>
              <actions>
                 <debug_text text="'VALRINN DEBUG: PrepareWareMovesTrigger signalled'" />
              </actions>
              <cues>
                <cue name="PrepareWareMoves">
                  <delay min="300ms" max="600ms" />
                  <actions>
                    <set_value name="$wareDesc" exact="$warePlan.{$wares.{$wareIndex}}" />
                    <do_if value="$stage == 1">
                      <!-- Stage 1 operations - suppliers to consumers. -->
                      <do_if value="$wareDesc.$suppliers.count gt 0 and $wareDesc.$consumers.count gt 0">
                        <run_actions ref="PrepareSupplierConsumerMoves">
                          <param name="moves" value="$wareDesc.$moves" />
                          <param name="suppliers" value="$wareDesc.$suppliers" />
                          <param name="consumers" value="$wareDesc.$consumers" />
                          <param name="maxJumps" value="$maxJumps" />
                        </run_actions>
                      </do_if>
                      <set_value name="$stage" operation="add" />
                      <reset_cue cue="this" />
                    </do_if>
                    <do_elseif value="$stage == 2">
                      <!-- Stage 2 operations - trade stations to consumers. -->
                      <do_if value="$wareDesc.$tradeHubs.count gt 0 and $wareDesc.$consumers.count gt 0">
                        <run_actions ref="PrepareSupplierConsumerMoves">
                          <param name="moves" value="$wareDesc.$moves" />
                          <param name="suppliers" value="$wareDesc.$tradeHubs.clone" /> <!--REMIND list itself cloned, element content changes as intended-->
                          <param name="consumers" value="$wareDesc.$consumers" />
                          <param name="maxJumps" value="$maxJumps" />
                        </run_actions>
                      </do_if>
                      <set_value name="$stage" operation="add" />
                      <reset_cue cue="this" />
                    </do_elseif>
                    <do_elseif value="$stage == 3">
                      <!-- Stage 3 operations - suppliers to trade stations. -->
                      <do_if value="$wareDesc.$suppliers.count gt 0 and $wareDesc.$tradeHubs.count gt 0">
                        <run_actions ref="PrepareSupplierConsumerMoves">
                          <param name="moves" value="$wareDesc.$moves" />
                          <param name="suppliers" value="$wareDesc.$suppliers" />
                          <param name="consumers" value="$wareDesc.$tradeHubs.clone" /> <!--REMIND list itself cloned, element content changes as intended-->
                          <param name="maxJumps" value="$maxJumps" />
                        </run_actions>
                      </do_if>
                      <set_value name="$stage" operation="add" />
                      <reset_cue cue="this" />
                    </do_elseif>
                    <do_else>
                      <!-- Remove unneeded lists (save file reduction). -->
                      <remove_value name="$wareDesc.$suppliers" />
                      <remove_value name="$wareDesc.$consumers" />
                      <remove_value name="$wareDesc.$tradeHubs" />
                      <!-- Next ware in plan. -->
                      <set_value name="$wareIndex" operation="add" />
                      <do_if value="$wareIndex le $wares.count">
                        <set_value name="$stage" exact="1" />
                        <reset_cue cue="this" />
                      </do_if>
                      <do_else>
                        <remove_value name="$stage" />
                        <!-- Start execution of ware movement plan. -->
                        <set_value name="$wareIndex" exact="1" />
                        <debug_text text="'VALRINN DEBUG: PrepareWareMoves complete. Signalling Execution.'" />
                        <signal_cue cue="ExecuteWareMovesPlanTrigger" />
                      </do_else>
                    </do_else>
                    <remove_value name="$wareDesc" />
                  </actions>
                </cue>
              </cues>
            </cue>
            <!-- Prepare ware movement operations from suppliers to consumers. -->
            <library name="PrepareSupplierConsumerMoves" purpose="run_actions">
              <params>
                <param name="moves" />
                <param name="suppliers" />
                <param name="consumers" />
                <param name="maxJumps" />
              </params>
              <actions>
                <!-- Calculate total supply. -->
                <set_value name="$totalSupply" exact="0" />
                <do_for_each name="$supplier" in="$suppliers">
                  <set_value name="$totalSupply" operation="add" exact="$supplier.$sellAmount" />
                </do_for_each>
                <!-- Calculate total demand. -->
                <set_value name="$totalDemand" exact="0" />
                <do_for_each name="$consumer" in="$consumers">
                  <set_value name="$totalDemand" operation="add" exact="$consumer.$buyAmount" />
                </do_for_each>
                <do_if value="$totalSupply gt 0 and $totalDemand gt 0">
                  <!-- Calculate consumer satisfaction level. -->
                  <set_value name="$consumeLevel" exact="if $totalSupply ge $totalDemand then 1.0 else ($totalSupply)f / ($totalDemand - 1)f" />
                  <!-- Process each consumer. Remove satisfied consumers and empty suppliers as we go. -->
                  <do_all exact="$consumers.count" counter="$i" reverse="true">
                    <set_value name="$consumer" exact="$consumers.{$i}" />
                    <do_if value="$consumer.$buyAmount le 0">
                      <remove_value name="$consumers.{$i}" />
                      <continue />
                    </do_if>
                    <set_value name="$consumerAmount" exact="[(($consumer.$buyAmount)f * $consumeLevel)i, 1].max" />
                    <!-- Filter suppliers by range -->
                    <do_if value="$maxJumps lt 999">
                       <do_all exact="$suppliers.count" counter="$k" reverse="true">
                          <do_if value="$suppliers.{$k}.$station.gatedistance.{$consumer.$station} gt $maxJumps">
                             <remove_value name="$suppliers.{$k}" />
                          </do_if>
                       </do_all>
                    </do_if>

                    <do_if value="$totalSupply gt $totalDemand">
                      <!-- Sort suppliers by distance to current consumer. -->
                      <sort_list list="$suppliers" sortbyvalue="loop.element.$station.gatedistance.{$consumer.$station}" sortdescending="true" />
                    </do_if>
                    <do_all exact="$suppliers.count" counter="$j" reverse="true">
                      <set_value name="$supplier" exact="$suppliers.{$j}" />
                      <set_value name="$amount" exact="[$consumerAmount, $supplier.$sellAmount].min" />
                      <do_if value="$amount gt 0">
                        <!-- Add ware movement operation from supplier to consumer. -->
                        <append_to_list name="$moves" exact="table[$sellerStation = $supplier.$station, $buyerStation = $consumer.$station, $amount = $amount]" />
                      </do_if>
                      <!-- Reduce or remove (empty) supplier. -->
                      <do_if value="$supplier.$sellAmount le $amount">
                        <remove_value name="$suppliers.{$j}" />
                      </do_if>
                      <do_else>
                        <set_value name="$supplier.$sellAmount" operation="subtract" exact="$amount" />
                      </do_else>
                      <!-- Reduce or remove (satisfied) consumer. -->
                      <do_if value="$consumer.$buyAmount le $amount">
                        <remove_value name="$consumers.{$i}" />
                        <break />
                      </do_if>
                      <do_else>
                        <set_value name="$consumer.$buyAmount" operation="subtract" exact="$amount" />
                      </do_else>
                      <!-- Reduce share or break (exhausted). -->
                      <do_if value="$consumerAmount le $amount">
                        <break />
                      </do_if>
                      <do_else>
                        <set_value name="$consumerAmount" operation="subtract" exact="$amount" />
                      </do_else>
                    </do_all>
                  </do_all>
                </do_if>
              </actions>
            </library>
            <!-- Execute ware movement plan.
              REMIND: Consider that plan ALWAYS ages during preparation (long time), so extra checks needed. -->
            <cue name="ExecuteWareMovesPlanTrigger">
              <conditions>
                <event_cue_signalled />
              </conditions>
              <cues>
                <cue name="ExecuteWareMovesPlan">
                  <delay min="400ms" max="1000ms" />
                  <actions>
                    <debug_text text="'VALRINN DEBUG: ExecuteWareMovesPlan executing for ware index: ' + $wareIndex" />
                    <set_value name="$ware" exact="$wares.{$wareIndex}" />
                    <set_value name="$moves" exact="$warePlan.{$ware}.$moves" />
                    <!-- Process each ware movement. -->
                    <do_for_each name="$moveDesc" in="$moves">
                      <debug_text text="'VALRINN DEBUG: Processing move for ' + $ware.name + ' Amount: ' + $moveDesc.$amount + ' From: ' + $moveDesc.$sellerStation.name + ' To: ' + $moveDesc.$buyerStation.name" />
                      <!-- Check stations are operational and different. TODO? modules not destroyed. -->
                      <do_if value="not $moveDesc.$sellerStation.isoperational or not $moveDesc.$buyerStation.isoperational or $moveDesc.$sellerStation == $moveDesc.$buyerStation">
                        <continue />
                      </do_if>
                      <set_value name="$distance" exact="$moveDesc.$sellerStation.gatedistance.{$moveDesc.$buyerStation} + 1" />
                      <set_value name="$energyAmount" exact="$moveDesc.$sellerStation.cargo.{WareTeleportation.$teleportEnergyWare}.count" />
                      <do_if value="$moveDesc.$sellerStation.resources.{WareTeleportation.$teleportEnergyWare}.exists">
                        <!-- Energy cells used by station for production - keep 10%. -->
                        <set_value name="$energyAmount" exact="[$energyAmount - ($moveDesc.$sellerStation.cargo.{WareTeleportation.$teleportEnergyWare}.target * 0.1)i, 0].max" />
                      </do_if>
                      <do_if value="$ware == WareTeleportation.$teleportEnergyWare">
                        <!-- How many energy cells can be counted on, if some used for transfer. -->
                        <set_value name="$poweredAmount" exact="($energyAmount / (1.0 + $ware.volume * $distance * WareTeleportation.$teleportEnergyCost))i" />
                      </do_if>
                      <do_else>
                        <!-- How many ware units can be transferred with available energy. -->
                        <set_value name="$poweredAmount" exact="($energyAmount / ($ware.volume * $distance * WareTeleportation.$teleportEnergyCost))i" />
                      </do_else>
                      <!-- Calculate allowable amount based on: desired amount; energy for transfer; sufficient supply; free space at consumer. -->
                      <set_value name="$wareAmount" exact="[$moveDesc.$amount, $poweredAmount, $moveDesc.$sellerStation.cargo.{$ware}.count, $moveDesc.$buyerStation.cargo.{$ware}.free].min" />
                      <do_if value="$wareAmount gt 0">
                        <!-- Transfer still possible. -->
                        <!-- Energy cost for transfer. -->
                        <set_value name="$energyCost" exact="[($wareAmount * $ware.volume * $distance * WareTeleportation.$teleportEnergyCost)i, 1].max" />
                        <!-- Directly transfer ware. -->
                        <remove_cargo object="$moveDesc.$sellerStation" ware="$ware" exact="$wareAmount" />
                        <add_cargo object="$moveDesc.$buyerStation" ware="$ware" exact="$wareAmount" />
                        <!-- Remove energy spent on transfer. -->
                        <remove_cargo object="$moveDesc.$sellerStation" ware="WareTeleportation.$teleportEnergyWare" exact="$energyCost" />
                        <!-- Add logbook entries. -->
                        <set_value name="$wareMoney" exact="$ware.averageprice * $wareAmount"/>
                        <set_value name="$energyMoney" exact="WareTeleportation.$teleportEnergyWare.averageprice * $energyCost" />
                        <write_to_logbook category="upkeep" object="$moveDesc.$sellerStation" title="{1016,71010}.[$moveDesc.$sellerStation.knownname, $moveDesc.$sellerStation.idcode]" text="{1016,71011}.[$wareAmount, $ware.name, $moveDesc.$buyerStation.knownname, $energyCost, WareTeleportation.$teleportEnergyWare.name]" interaction="showonmap" money="-$wareMoney" bonus="-$energyMoney" />
                        <write_to_logbook category="upkeep" object="$moveDesc.$buyerStation" title="{1016,71012}.[$moveDesc.$buyerStation.knownname, $moveDesc.$buyerStation.idcode]" text="{1016,71013}.[$wareAmount, $ware.name, $moveDesc.$sellerStation.knownname]" interaction="showonmap" money="$wareMoney" />
                        <remove_value name="$wareMoney" />
                        <remove_value name="$energyMoney" />
                      </do_if>
                      <remove_value name="$distance" />
                      <remove_value name="$energyAmount" />
                      <remove_value name="$poweredAmount" />
                      <remove_value name="$wareAmount" />
                      <remove_value name="$energyCost" />
                    </do_for_each>
                    <remove_value name="$ware" />
                    <remove_value name="$moves" />
                    <!-- Next ware in plan. -->
                    <set_value name="$wareIndex" operation="add" />
                    <do_if value="$wareIndex le $wares.count">
                      <reset_cue cue="this" />
                    </do_if>
                    <do_else>
                      <remove_value name="$wares" />
                      <remove_value name="$wareIndex" />
                      <remove_value name="$warePlan" />
                      <cancel_cue cue="namespace" />
                    </do_else>
                  </actions>
                </cue>
              </cues>
            </cue>
          </cues>
        </cue>

        <library name="DumpWarePlan" purpose="include_actions">
          <actions>
            <do_for_each name="$ware" valuename="$wareDesc" in="$warePlan">
              <do_for_each name="$supplier" in="$wareDesc.$suppliers">
              </do_for_each>
              <do_for_each name="$consumer" in="$wareDesc.$consumers">
              </do_for_each>
              <do_for_each name="$tradeHub" in="$wareDesc.$tradeHubs">
              </do_for_each>
              <do_for_each name="$moveDesc" in="$wareDesc.$moves">
              </do_for_each>
            </do_for_each>
          </actions>
        </library>
      </cues>
    </cue>
  </cues>
</mdscript>
